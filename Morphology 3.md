# Морфология 3
В этом семинаре нам придется познакомится с морфологическим синтезом на примере FOMA - компилятора для конечных преобразований.

Их сайт: https://fomafst.github.io/

## Getting started
Для начала разберем туториал с их сайта.
### Установка:
Для установки на Debian/Ubuntu можно воспользоваться командой
~~~
apt instal foma
~~~ 
Для Windows и Mac качаем бинарники с их сайта.

### Базовые команды
Для задания регулярного выражения используется команда: `regex REGULAR-EXPRESSION ;`
Также можно давать имена выражениям для последующего использования: `def NAME REGEX ;` 
А для того, чтобы вывести все слова реализуемые текущим автоматом существует команда `words`
Пример:
```
> def char a|b ;
> regex char char ;
> words
aa
ab
ba
bb
``` 
Также, если установлен *GraphViz*, то можно нарисовать граф текущего автомата с помощью команды `view`. 
Однако это работает только на UNIX-подобных системах. По крайней мере можно использовать команду `net`, 
которая выведет ASCII листинг:
```
> net
Sigma: a b
Size 2.
Net: 234E2BE34
Flags: deterministic pruned minimized epsilon_free loop_free
Arity: 1
Ss0: a -> s1, b -> s1.
s1: a -> fs2, b -> fs2.
fs2: (no arcs).
```  
Помимо конечных автоматов можно использовать конечные преобразователи.
 Регулярные выражения задаются с добавлением знака `:`, означающего, что куда преобразовывать.
 Чтобы вывести всевозможные пары вход-выход используется команда `pairs`, а чтобы преобразовать слово используется 
команда `down` или `up` для преобразования в обратную сторону. Пример:
```
> regex a:b b:a ;
> pairs 
ab ba
> down 
down> ab
ba
> up 
up> ba
ab
``` 

### Синтаксис
Местный синтаксис немного отличается от такого в том же питоновском `re`. Перечислим главные отличия:
- Все ругулярные выражения заканчиваются на `;`
- Для грппировки используются квадратные скобки и нет символьных классов типа `[A-Z]`. Перечислять символы придется ручками.
- Опциональные элементы указываются в круглых скобках: `a b (c)` даст два слова `ab` и `abc`.
- "Любой символ" представлен знаком вопроса, а не точкой
- Помимо объединения `|` также есть пересечение `&` и дополнинние `~`. Например, для задания слов, начинающихся и заканчивающихся
на `a`, можно использовать выражение `a ?* & ?* a`
- Спец символы помещаются в кавычки или пере ними ставится знак `%`: `"_"` или `%_` 
- Символы для описания преобразователей: `:`, `.o.` и `->` 
- Пустой символ представляется как `0`  
- Одиночные символы разделяются пробелом, слова же могут использоваться для переменных.

### Преобразователи
С преобразователями мы уже немного познакомились: можно добавлять знак `:` в регулярное выражение для замены. 
Но возможно это не лучший синтаксис. Для моделирования морфологии часто используются так нызываемые rewrite rules:
```
LHS -> RHS || LC _ RC
``` 
где `LHS` - левая сторона (что преобразуется), `RHS` - правая сторона (во что преобразуется),
 `LC` - левый контекст, `RC` - правый контекст.
Например, регулярное выражение
```
regex a -> b || c _ d
```
заменит все `a` на `b` только между `c` и `d`. Левый и правый контексты могут быть опциональными. 
Также можно использовать спец символ `.#.` для обозначения краев слов. Для вставки "из ничего" (когда `LHS` пустой) используется 
символ `[..]`. Еще можно объединять преобразователи с помощью знака композиции `.0.`. Например:
```
> regex a -> b .o. b -> c ;
> down
down> abc
ccc 
```